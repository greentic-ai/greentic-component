use std::collections::{BTreeMap, BTreeSet};

use greentic_types::cbor::canonical;
use greentic_types::schemas::common::schema_ir::{AdditionalProperties, SchemaIr};
use greentic_types::schemas::component::v0_6_0::{
    ComponentDescribe, ComponentInfo, ComponentOperation, ComponentQaSpec, ComponentRunInput,
    ComponentRunOutput, I18nText, QaMode, Question, schema_hash,
};

const COMPONENT_NAME: &str = "{{ name }}";
const COMPONENT_ORG: &str = "{{ org }}";
const COMPONENT_VERSION: &str = "{{ version }}";

wit_bindgen::generate!({
    path: "wit",
    world: "component-v0-v6-v0",
});

#[cfg(target_arch = "wasm32")]
#[used]
#[unsafe(link_section = ".greentic.wasi")]
static WASI_TARGET_MARKER: [u8; 13] = *b"wasm32-wasip2";

struct Component;

impl exports::greentic::component::component_descriptor::Guest for Component {
    fn get_component_info() -> Vec<u8> {
        component_info_cbor()
    }

    fn describe() -> Vec<u8> {
        component_describe_cbor()
    }
}

impl exports::greentic::component::component_schema::Guest for Component {
    fn input_schema() -> Vec<u8> {
        input_schema_cbor()
    }

    fn output_schema() -> Vec<u8> {
        output_schema_cbor()
    }

    fn config_schema() -> Vec<u8> {
        config_schema_cbor()
    }
}

impl exports::greentic::component::component_qa::Guest for Component {
    fn qa_spec(mode: exports::greentic::component::component_qa::QaMode) -> Vec<u8> {
        qa_spec_cbor(mode)
    }

    fn apply_answers(
        mode: exports::greentic::component::component_qa::QaMode,
        current_config: Vec<u8>,
        answers: Vec<u8>,
    ) -> Vec<u8> {
        apply_answers_cbor(mode, current_config, answers)
    }
}

impl exports::greentic::component::component_i18n::Guest for Component {
    fn i18n_keys() -> Vec<String> {
        i18n_keys()
    }
}

impl exports::greentic::component::component_runtime::Guest for Component {
    fn run(
        input: Vec<u8>,
        state: Vec<u8>,
    ) -> exports::greentic::component::component_runtime::RunResult {
        let (output, new_state) = run_component_cbor(input, state);
        exports::greentic::component::component_runtime::RunResult { output, new_state }
    }
}

#[cfg(target_arch = "wasm32")]
export!(Component);

pub fn describe_payload() -> String {
    serde_json::json!({
        "component": {
            "name": COMPONENT_NAME,
            "org": COMPONENT_ORG,
            "version": COMPONENT_VERSION,
            "world": "{{ wit_world }}",
            "schemas": {
                "component": "schemas/component.schema.json",
                "input": "schemas/io/input.schema.json",
                "output": "schemas/io/output.schema.json"
            }
        }
    })
    .to_string()
}

pub fn handle_message(operation: &str, input: &str) -> String {
    format!("{COMPONENT_NAME}::{operation} => {}", input.trim())
}

fn encode_cbor<T: serde::Serialize>(value: &T) -> Vec<u8> {
    canonical::to_canonical_cbor_allow_floats(value).expect("encode cbor")
}

fn input_schema() -> SchemaIr {
    SchemaIr::Object {
        properties: BTreeMap::from([(
            "input".to_string(),
            SchemaIr::String {
                min_len: Some(0),
                max_len: None,
                regex: None,
                format: None,
            },
        )]),
        required: vec!["input".to_string()],
        additional: AdditionalProperties::Allow,
    }
}

fn output_schema() -> SchemaIr {
    SchemaIr::Object {
        properties: BTreeMap::from([(
            "message".to_string(),
            SchemaIr::String {
                min_len: Some(0),
                max_len: None,
                regex: None,
                format: None,
            },
        )]),
        required: vec!["message".to_string()],
        additional: AdditionalProperties::Allow,
    }
}

fn config_schema() -> SchemaIr {
    SchemaIr::Object {
        properties: BTreeMap::new(),
        required: Vec::new(),
        additional: AdditionalProperties::Forbid,
    }
}

fn component_info() -> ComponentInfo {
    ComponentInfo {
        id: format!("{COMPONENT_ORG}.{COMPONENT_NAME}"),
        version: COMPONENT_VERSION.to_string(),
        role: "tool".to_string(),
        display_name: Some(I18nText::new(
            "component.display_name",
            Some(COMPONENT_NAME.to_string()),
        )),
    }
}

fn component_describe() -> ComponentDescribe {
    let input = input_schema();
    let output = output_schema();
    let config = config_schema();
    let hash = schema_hash(&input, &output, &config).unwrap_or_default();
    ComponentDescribe {
        info: component_info(),
        provided_capabilities: Vec::new(),
        required_capabilities: Vec::new(),
        metadata: BTreeMap::new(),
        operations: vec![ComponentOperation {
            id: "handle_message".to_string(),
            display_name: None,
            input: ComponentRunInput { schema: input },
            output: ComponentRunOutput { schema: output },
            defaults: BTreeMap::new(),
            redactions: Vec::new(),
            constraints: BTreeMap::new(),
            schema_hash: hash,
        }],
        config_schema: config,
    }
}

fn component_info_cbor() -> Vec<u8> {
    encode_cbor(&component_info())
}

fn component_describe_cbor() -> Vec<u8> {
    encode_cbor(&component_describe())
}

fn input_schema_cbor() -> Vec<u8> {
    encode_cbor(&input_schema())
}

fn output_schema_cbor() -> Vec<u8> {
    encode_cbor(&output_schema())
}

fn config_schema_cbor() -> Vec<u8> {
    encode_cbor(&config_schema())
}

fn qa_spec_cbor(mode: exports::greentic::component::component_qa::QaMode) -> Vec<u8> {
    let mode = match mode {
        exports::greentic::component::component_qa::QaMode::Default => QaMode::Default,
        exports::greentic::component::component_qa::QaMode::Setup => QaMode::Setup,
        exports::greentic::component::component_qa::QaMode::Upgrade => QaMode::Upgrade,
        exports::greentic::component::component_qa::QaMode::Remove => QaMode::Remove,
    };

    let spec = ComponentQaSpec {
        mode,
        title: I18nText::new("qa.title", Some("Component settings".to_string())),
        description: None,
        questions: vec![Question {
            id: "enabled".to_string(),
            label: I18nText::new("qa.enabled.label", Some("Enabled".to_string())),
            help: None,
            error: None,
            kind: greentic_types::schemas::component::v0_6_0::QuestionKind::Bool,
            required: false,
            default: None,
        }],
        defaults: BTreeMap::new(),
    };
    encode_cbor(&spec)
}

fn apply_answers_cbor(
    _mode: exports::greentic::component::component_qa::QaMode,
    current_config: Vec<u8>,
    answers: Vec<u8>,
) -> Vec<u8> {
    let current: Result<serde_json::Value, _> = canonical::from_cbor(&current_config);
    let incoming: Result<serde_json::Value, _> = canonical::from_cbor(&answers);
    let merged = match (current.ok(), incoming.ok()) {
        (_, Some(value @ serde_json::Value::Object(_))) => value,
        (Some(value @ serde_json::Value::Object(_)), _) => value,
        _ => serde_json::json!({}),
    };
    encode_cbor(&merged)
}

fn i18n_keys() -> Vec<String> {
    let mut keys = BTreeSet::new();
    keys.insert("component.display_name".to_string());
    keys.insert("qa.title".to_string());
    keys.insert("qa.enabled.label".to_string());
    keys.into_iter().collect()
}

fn run_component_cbor(input: Vec<u8>, _state: Vec<u8>) -> (Vec<u8>, Vec<u8>) {
    let invocation: Result<serde_json::Value, _> = canonical::from_cbor(&input);
    let output = match invocation {
        Ok(value) => {
            let operation = value
                .get("operation")
                .and_then(|v| v.as_str())
                .unwrap_or("handle_message");
            let input_text = value
                .get("input")
                .and_then(|v| v.as_str())
                .map(ToOwned::to_owned)
                .unwrap_or_else(|| value.to_string());
            serde_json::json!({
                "message": handle_message(operation, &input_text)
            })
        }
        Err(err) => serde_json::json!({
            "error": {
                "code": "SCHEMA_INVALID",
                "message": err.to_string()
            }
        }),
    };

    (encode_cbor(&output), encode_cbor(&serde_json::json!({})))
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn describe_payload_is_json() {
        let payload = describe_payload();
        let json: serde_json::Value = serde_json::from_str(&payload).expect("valid json");
        assert_eq!(json["component"]["name"], "{{ name }}");
    }

    #[test]
    fn handle_message_round_trips() {
        let body = handle_message("handle", "demo");
        assert!(body.contains("demo"));
    }
}
